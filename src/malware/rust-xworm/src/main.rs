//! # Rust XWorm - Educational Malware Implementation
//!
//! This is an EDUCATIONAL implementation demonstrating techniques observed in XWorm malware.
//! Based on analysis from: https://cofense.com/blog/pythonratloader-the-proprietor-of-xworm-and-friends
//!
//! **WARNING**: This code is for AUTHORIZED SECURITY RESEARCH AND EDUCATION ONLY.
//! Unauthorized use is illegal and unethical.
//!
//! ## Techniques Implemented (MITRE ATT&CK):
//! - T1547: Boot or Logon Autostart Execution (Registry Run Keys)
//! - T1055.004: Process Injection (Early Bird APC Injection)
//! - T1057: Process Discovery
//! - T1087: Account Discovery
//! - T1082: System Information Discovery
//! - T1056.001: Input Capture (Keylogging)
//! - T1573: Encrypted Channel (RC4 C2 Communications)
//! - T1027: Obfuscated Files or Information (RC4 Encryption)

#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use std::thread;
use std::time::Duration;

#[cfg(windows)]
use windows::Win32::Foundation::*;
#[cfg(windows)]
use windows::Win32::System::Diagnostics::ToolHelp::*;
#[cfg(windows)]
use windows::Win32::System::Memory::*;
#[cfg(windows)]
use windows::Win32::System::Registry::*;
#[cfg(windows)]
use windows::Win32::System::Threading::*;
#[cfg(windows)]
use windows::Win32::UI::Input::KeyboardAndMouse::*;

mod crypto;
mod discovery;
mod evasion;
mod persistence;
mod c2;

/// Main entry point for Rust XWorm
fn main() {
    println!("[*] Rust XWorm - Educational Malware Research");
    println!("[*] Based on XWorm analysis by Cofense");
    println!("[!] FOR AUTHORIZED SECURITY RESEARCH ONLY\n");

    // Check if running in safe mode (educational demonstration)
    let safe_mode = std::env::var("XWORM_SAFE_MODE").unwrap_or_default() == "1";

    if !safe_mode {
        eprintln!("[!] ERROR: Set XWORM_SAFE_MODE=1 to run this educational demonstration");
        eprintln!("[!] This ensures you're aware this is for research purposes only");
        return;
    }

    println!("[+] Running in SAFE MODE (demonstration only)\n");

    // Demonstrate XWorm techniques
    demonstrate_techniques();
}

/// Demonstrates various XWorm techniques in a safe, educational manner
fn demonstrate_techniques() {
    println!("=== XWorm Technique Demonstrations ===\n");

    // 1. System Discovery (T1082)
    println!("[1] System Information Discovery (T1082)");
    let system_info = discovery::gather_system_info();
    println!("{}", system_info);

    // 2. Process Discovery (T1057)
    println!("\n[2] Process Discovery (T1057)");
    let processes = discovery::enumerate_processes();
    println!("    Found {} running processes", processes.len());
    for (i, proc) in processes.iter().take(5).enumerate() {
        println!("    {}. {} (PID: {})", i + 1, proc.name, proc.pid);
    }
    println!("    ... (showing first 5)\n");

    // 3. Account Discovery (T1087)
    println!("[3] Account Discovery (T1087)");
    let account_info = discovery::get_current_user_info();
    println!("{}", account_info);

    // 4. RC4 Encryption Demo (T1027)
    println!("\n[4] RC4 Encryption Demo (T1027 - Obfuscation)");
    let plaintext = b"This is XWorm C2 communication";
    let key = b"xworm_key_2024";
    let encrypted = crypto::rc4_encrypt(plaintext, key);
    let decrypted = crypto::rc4_decrypt(&encrypted, key);
    println!("    Original:  {}", String::from_utf8_lossy(plaintext));
    println!("    Encrypted: {} (base64)", base64::encode(&encrypted));
    println!("    Decrypted: {}\n", String::from_utf8_lossy(&decrypted));

    // 5. Persistence Techniques (T1547)
    println!("[5] Persistence Technique Demo (T1547)");
    println!("    XWorm uses Registry Run Keys for persistence:");
    println!("    Key: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run");
    println!("    Value: [malware_name] = [executable_path]");
    println!("    [DEMO ONLY - Not actually creating registry entry]\n");

    // 6. Early Bird APC Injection (T1055.004)
    println!("[6] Early Bird APC Injection (T1055.004)");
    println!("    Technique: Create suspended process → Queue APC → Resume");
    println!("    Target: notepad.exe (common XWorm target)");
    println!("    [DEMO ONLY - Not performing actual injection]\n");

    // 7. Keylogging Capability (T1056.001)
    println!("[7] Keylogging Capability (T1056.001)");
    println!("    Uses GetAsyncKeyState to monitor keyboard input");
    println!("    Logs stored in encrypted format for exfiltration");
    println!("    [DEMO ONLY - Not capturing actual keystrokes]\n");

    // 8. C2 Communication (T1573)
    println!("[8] Encrypted C2 Channel (T1573)");
    println!("    Protocol: HTTPS with RC4 encrypted payload");
    println!("    Commands: Download, Execute, Upload, SystemInfo");
    println!("    [DEMO ONLY - No actual C2 connection]\n");

    println!("=== Demonstration Complete ===");
    println!("\n[*] All techniques demonstrated safely without actual malicious activity");
    println!("[*] See rust-xworm.md wiki for detailed analysis");
}

// Module stubs for educational implementations
mod crypto {
    use rc4::{KeyInit, StreamCipher, Rc4};

    /// RC4 encryption (as used by XWorm)
    pub fn rc4_encrypt(data: &[u8], key: &[u8]) -> Vec<u8> {
        let mut cipher = Rc4::new(key.into());
        let mut buffer = data.to_vec();
        cipher.apply_keystream(&mut buffer);
        buffer
    }

    /// RC4 decryption (as used by XWorm)
    pub fn rc4_decrypt(data: &[u8], key: &[u8]) -> Vec<u8> {
        // RC4 is symmetric
        rc4_encrypt(data, key)
    }
}

mod discovery {
    use sysinfo::{System, Users};

    #[derive(Debug)]
    pub struct ProcessInfo {
        pub pid: u32,
        pub name: String,
    }

    /// T1082: System Information Discovery
    pub fn gather_system_info() -> String {
        let mut sys = System::new_all();
        sys.refresh_all();

        let os_name = System::name().unwrap_or_else(|| "Unknown".to_string());
        let os_version = System::os_version().unwrap_or_else(|| "Unknown".to_string());
        let kernel_version = System::kernel_version().unwrap_or_else(|| "Unknown".to_string());
        let hostname = System::host_name().unwrap_or_else(|| "Unknown".to_string());

        let total_memory = sys.total_memory() / (1024 * 1024);
        let used_memory = sys.used_memory() / (1024 * 1024);
        let cpu_count = sys.cpus().len();

        format!(
            "    Hostname: {}\n    OS: {} {}\n    Kernel: {}\n    CPU Cores: {}\n    Memory: {} MB / {} MB",
            hostname, os_name, os_version, kernel_version, cpu_count, used_memory, total_memory
        )
    }

    /// T1057: Process Discovery
    pub fn enumerate_processes() -> Vec<ProcessInfo> {
        let mut sys = System::new();
        sys.refresh_processes();

        sys.processes()
            .iter()
            .map(|(pid, process)| ProcessInfo {
                pid: pid.as_u32(),
                name: process.name().to_string(),
            })
            .collect()
    }

    /// T1087: Account Discovery
    pub fn get_current_user_info() -> String {
        let users = Users::new_with_refreshed_list();
        let current_user = std::env::var("USER")
            .or_else(|_| std::env::var("USERNAME"))
            .unwrap_or_else(|_| "Unknown".to_string());

        format!(
            "    Current User: {}\n    Total Users: {}",
            current_user,
            users.list().len()
        )
    }
}

mod evasion {
    //! T1055.004: Early Bird APC Injection
    //!
    //! XWorm uses Early Bird APC injection to evade detection:
    //! 1. Create target process (notepad.exe) in suspended state
    //! 2. Allocate memory in target process
    //! 3. Write shellcode to allocated memory
    //! 4. Queue APC to main thread before it starts
    //! 5. Resume thread - APC executes before any other code
    //!
    //! This technique bypasses many AV solutions that monitor running processes.

    #[cfg(windows)]
    pub unsafe fn early_bird_apc_injection_demo() {
        // EDUCATIONAL DEMONSTRATION ONLY
        // Actual implementation would:
        // 1. CreateProcess with CREATE_SUSPENDED
        // 2. VirtualAllocEx to allocate RWX memory
        // 3. WriteProcessMemory to write shellcode
        // 4. QueueUserAPC to queue shellcode execution
        // 5. ResumeThread to trigger APC

        println!("    [DEMO] Would create suspended notepad.exe");
        println!("    [DEMO] Would allocate RWX memory in target");
        println!("    [DEMO] Would queue APC with shellcode pointer");
        println!("    [DEMO] Would resume thread to execute shellcode");
    }
}

mod persistence {
    //! T1547: Boot or Logon Autostart Execution
    //!
    //! XWorm establishes persistence via Windows Registry Run keys:
    //! HKCU\Software\Microsoft\Windows\CurrentVersion\Run
    //!
    //! This ensures the malware starts whenever the user logs in.

    #[cfg(windows)]
    pub unsafe fn install_persistence_demo() {
        // EDUCATIONAL DEMONSTRATION ONLY
        // Actual implementation would use RegCreateKeyEx and RegSetValueEx
        println!("    [DEMO] Would create registry run key");
        println!("    [DEMO] Key: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run");
        println!("    [DEMO] Value: XWormClient = C:\\Path\\To\\Malware.exe");
    }
}

mod c2 {
    //! T1573: Encrypted Channel
    //!
    //! XWorm uses encrypted C2 communications over HTTPS:
    //! - Commands encrypted with RC4
    //! - Data exfiltration over encrypted channel
    //! - Common commands: DOWNLOAD, EXECUTE, UPLOAD, INFO, KEYLOG

    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, Debug)]
    pub enum Command {
        Download { url: String },
        Execute { command: String },
        Upload { path: String },
        SystemInfo,
        Keylog { duration_seconds: u64 },
    }

    #[derive(Serialize, Deserialize, Debug)]
    pub struct C2Message {
        pub command: Command,
        pub timestamp: u64,
        pub machine_id: String,
    }

    pub fn parse_c2_command(encrypted_data: &[u8], key: &[u8]) -> Option<Command> {
        // EDUCATIONAL DEMONSTRATION ONLY
        // Actual implementation would:
        // 1. Decrypt with RC4
        // 2. Parse JSON command
        // 3. Execute appropriate handler
        println!("    [DEMO] Would decrypt C2 message with RC4");
        println!("    [DEMO] Would parse JSON command structure");
        println!("    [DEMO] Would dispatch to command handler");
        None
    }

    pub fn send_c2_response(data: &[u8], key: &[u8], c2_url: &str) {
        // EDUCATIONAL DEMONSTRATION ONLY
        println!("    [DEMO] Would encrypt response with RC4");
        println!("    [DEMO] Would send to C2: {}", c2_url);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rc4_encryption() {
        let data = b"Test XWorm payload";
        let key = b"test_key";
        let encrypted = crypto::rc4_encrypt(data, key);
        let decrypted = crypto::rc4_decrypt(&encrypted, key);
        assert_eq!(data.to_vec(), decrypted);
    }

    #[test]
    fn test_system_discovery() {
        let info = discovery::gather_system_info();
        assert!(info.contains("Hostname"));
        assert!(info.contains("OS"));
    }

    #[test]
    fn test_process_enumeration() {
        let processes = discovery::enumerate_processes();
        assert!(processes.len() > 0);
    }
}
